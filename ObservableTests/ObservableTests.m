/****************************************************************************************************
	ObservableTests.m
	Observable
	
    Created by Chall Fry on 4/19/14.
    Copyright (c) 2013-2014 eBay Software Foundation.

    Unit tests.
*/

#import <XCTest/XCTest.h>
#import "EBNObservable.h"

// This punches the hole that allows us to force the observer notifications
// instead of being dependent on the run loop. Asyncronous issues
// have to be handled without this.
void EBN_RunLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info);


// -----------------------------------------------------------------------------
//                              Test Objects
// -----------------------------------------------------------------------------
@class ModelObjectA;
@class ModelObjectB;
@class ModelObjectC;
@class ModelObjectD;

//
// Observable Test Object A.
//
@interface ModelObjectA : EBNObservable

@property (assign) bool					boolProperty;
@property (getter = isCustomBoolProperty) bool customBoolProperty;
@property (assign) int					intProperty;
@property (assign) char					charProperty;
@property (assign) double				doubleProperty;

@property NSString						*stringProperty1;

@property (nonatomic) ModelObjectB		*modelObjectBProperty;
@property (nonatomic) ModelObjectC		*modelObjectCProperty;

@property (nonatomic) bool 				objectCWasDealloced;

// Allow objectCWasDealloced to be changed outside setter.
- (void) changeObjectCWasDeallocedValue:(bool)dealloced;

@end

//
// Observable Test Object B
//
@interface ModelObjectB : EBNObservable

@property (assign) int					intProperty;

@property NSString						*stringProperty;

@property (readonly) ModelObjectA		*readonlyProperty;
@property (strong) ModelObjectC			*modelObjectCProperty;

@end

//
// Protocol used by Test Object C
//
@protocol ModelObjectCProtocol <NSObject>

@property int							protocolIntProperty;

@end

//
// Observable Test Object C
//
@interface ModelObjectC : ModelObjectB <ModelObjectCProtocol>

@property NSString						*stringProperty4;
@property ModelObjectA					*modelObjectAProperty;

@end

//
// Observable Test Object C Category
//
@interface ModelObjectC (CategoryNameGoesHere)

@property float							categoryFloatProperty;

@end

// ------------------------ Test Object Implementations ------------------------

@implementation ModelObjectA

- (void) changeObjectCWasDeallocedValue:(bool)dealloced
{
    _objectCWasDealloced = dealloced;
}

@end

@implementation ModelObjectB

- (instancetype) init
{
	if (self = [super init])
	{
		// Have to set up the readonly property up front.
		_readonlyProperty = [[ModelObjectA alloc] init];
	}
	return self;
}

@end


@implementation ModelObjectC

@synthesize protocolIntProperty;

- (void) dealloc
{
	if (self.modelObjectAProperty)
        [self.modelObjectAProperty changeObjectCWasDeallocedValue:true];
}

@end

@implementation ModelObjectC (CategoryNameGoesHere)

- (float) categoryFloatProperty
{
	// You can declare a property in a category, but you can't back it with an ivar, which means
	// you can't @synthesize it--as the autogenerated getter and setter need to use the ivar that isn't there.
	return 42.0;
}

- (void) setCategoryFloatProperty:(float)categoryFloatProperty
{
	// Oh yeah, we set that value alright.
}

@end


// -----------------------------------------------------------------------------
// Observable Tests
// -----------------------------------------------------------------------------
@interface ObservableTests : XCTestCase
{
	// These are deliberately not properties.
	ModelObjectA *moA;
}

@property (nonatomic) int observerCallCount1;			// Counts the number of times a test's observer block is called.
@property (nonatomic) int observerCallCount2;			// Counts the number of times a test's observer block is called.
@property (nonatomic) int propValInBlock;				// Receives the new integer value of the observed property.

@property (nonatomic) bool deallocWasCalled;			// Used by testObservedDealloc to confirm that dealloc message for observed property is triggered.
@property (nonatomic) bool appleKVOWasCalled;			// Used by testAppleKVOCompatibility to confirm that EBNObservable is compatible with Apple's KVO.


@end


@implementation ObservableTests

- (void) setUp
{
    [super setUp];
    
    self.observerCallCount1 = 0;
    self.observerCallCount2 = 0;
    self.propValInBlock = 0;
    
    _deallocWasCalled = false;
    //	_ModelObjectCWasDealloced = false;
	_appleKVOWasCalled = false;
	
	moA = [[ModelObjectA alloc] init];
	moA.intProperty = 99;
	moA.stringProperty1 = @"old value";
	moA.modelObjectBProperty = [[ModelObjectB alloc] init];
	moA.modelObjectCProperty = [[ModelObjectC alloc] init];
	moA.modelObjectBProperty.modelObjectCProperty = [[ModelObjectC alloc] init];
}

- (void) tearDown
{
    [super tearDown];
}

- (void) testBasicObservation
{
	ObserveProperty(moA, intProperty,
	{
		blockSelf.observerCallCount1++;
		_propValInBlock = observed.intProperty;
	});
	
	moA.intProperty = 5;
	
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called.");
	XCTAssertEqual(self.propValInBlock, 5, @"Property doesn't have the value it should.");
}

- (void) testBasicObservationKeypath
{
	[moA tell:self when:@"modelObjectBProperty.intProperty" changes:
			^(ObservableTests *blockSelf, ModelObjectA *observed)
			{
				blockSelf.observerCallCount1++;
				blockSelf.propValInBlock = observed.modelObjectBProperty.intProperty;
			}];
	
	moA.modelObjectBProperty.intProperty = 8;
	moA.modelObjectBProperty = nil;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);

	moA.modelObjectBProperty = [[ModelObjectB alloc] init];
	moA.modelObjectBProperty.intProperty = 5;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	
	XCTAssertEqual(self.observerCallCount1, 2, @"Observation block got called wrong number of times.");
	XCTAssertEqual(self.propValInBlock, 5, @"Property doesn't have the value it should.");
}

- (void) testBasicObservationRemoval
{
	ObserveProperty(moA, intProperty,
	{
		blockSelf.observerCallCount1++;
		blockSelf.propValInBlock = observed.intProperty;
	});
	
	moA.intProperty = 4;
	moA.intProperty = 5;
	[moA stopTellingAboutChanges:self];
	moA.intProperty = 6;
	
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	
	moA.intProperty = 10;
	
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got too many times.");
	XCTAssertEqual(self.propValInBlock, 6, @"Observation block got called with wrong value.");
}

- (void) testBasicObservationKeypathRemoval
{
	ObserveProperty(moA, modelObjectBProperty.intProperty,
	{
		blockSelf.observerCallCount1++;
		blockSelf.propValInBlock = observed.modelObjectBProperty.intProperty;
	});
	
	moA.intProperty = 4;
	moA.modelObjectBProperty.intProperty = 5;
	[moA stopTellingAboutChanges:self];
	moA.modelObjectBProperty.intProperty = 6;
	
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	
	moA.modelObjectBProperty.intProperty = 10;

	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called too many times.");
	XCTAssertEqual(self.propValInBlock, 6, @"Observation block got called with wrong value.");
}

- (void) testArrayObservation
{
	__block NSString *stringValInBlock = nil;
	
	[moA tell:self whenAny:@[@"stringProperty1", @"intProperty", @"modelObjectBProperty"]
			changes:^(ObservableTests *blockSelf, ModelObjectA *observed)
			{
				blockSelf.observerCallCount1++;
				blockSelf.propValInBlock = observed.intProperty;
				stringValInBlock = [observed.stringProperty1 copy];
			}];
				
	moA.intProperty = 4;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called too many times.");
	XCTAssertEqual(self.propValInBlock, 4, @"Observation block got called with wrong value.");

	self.observerCallCount1 = 0;
	moA.stringProperty1 = @"new value";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called too many times.");
	XCTAssertEqualObjects(stringValInBlock, @"new value", @"Observation block got called with wrong value.");

	self.observerCallCount1 = 0;
	moA.modelObjectBProperty.intProperty = 6;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 0, @"Observation block got called too many times.");
	
	self.observerCallCount1 = 0;
	moA.modelObjectBProperty = [[ModelObjectB alloc] init];
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called too many times.");

	self.observerCallCount1 = 0;
	moA.stringProperty1 = @"newer value";
	moA.intProperty = 10;
	moA.modelObjectBProperty = [[ModelObjectB alloc] init];
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called too many times.");
	XCTAssertEqual(self.propValInBlock, 10, @"Observation block got called with wrong value.");
	XCTAssertEqualObjects(stringValInBlock, @"newer value", @"Observation block got called with wrong value.");

	self.observerCallCount1 = 0;
	[moA stopTellingAboutChanges:self];
	moA.stringProperty1 = @"newest value";
	moA.intProperty = 11;
	moA.modelObjectBProperty = [[ModelObjectB alloc] init];
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 0, @"Observation block got called too many times.");
}

- (void) testArrayObservationKeypath
{
	__block int intVal2InBlock = 0;
	__block NSString *stringValInBlock = nil;
	
	[moA tell:self whenAny:@[@"modelObjectBProperty.intProperty", @"intProperty",
			@"modelObjectBProperty.modelObjectCProperty.stringProperty4"]
			changes:^(ObservableTests *blockSelf, ModelObjectA *observed)
			{
				blockSelf.observerCallCount1++;
				blockSelf.propValInBlock = observed.intProperty;
				intVal2InBlock = observed.modelObjectBProperty.intProperty;
				stringValInBlock = [observed.modelObjectBProperty.modelObjectCProperty.stringProperty4 copy];
			}];

	NSLog(@"%@", [moA debugShowAllObservers]);

	moA.modelObjectBProperty.intProperty = 40;
	moA.intProperty = 33;
	moA.modelObjectBProperty.modelObjectCProperty.stringProperty4 = @"some value";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called too many times.");
	XCTAssertEqual(self.propValInBlock, 33, @"Observation block got called with wrong value.");
	
	self.observerCallCount1 = 0;
	moA.modelObjectBProperty = nil;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called too many times.");
	XCTAssertEqual(intVal2InBlock, 0, @"Observation block got called with wrong value.");

	self.observerCallCount1 = 0;
	moA.modelObjectBProperty = [[ModelObjectB alloc] init];
	moA.modelObjectBProperty.modelObjectCProperty = [[ModelObjectC alloc] init];
	moA.modelObjectBProperty.modelObjectCProperty.stringProperty4 = @"changed value";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block didn't get called.");
	XCTAssertEqualObjects(stringValInBlock, @"changed value", @"Observation block got called with wrong value.");

}

- (void) testObserveAll
{
	EBNObservation *blockInfo = NewObservationBlock(moA,
	{
		blockSelf.observerCallCount1++;
	});
	
	[blockInfo observe:@"*"];
	
	moA.intProperty = 33;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	moA.doubleProperty = 33.0;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	moA.charProperty = 'x';
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	[moA setStringProperty1:@"what?"];
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 4, @"Observation block got called wrong number of times.");
	
	moA.modelObjectBProperty.stringProperty	= @"who?";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 4, @"Observation block got called wrong number of times.");
	
	NSLog(@"moA Observed Properties: %@", [moA allObservedProperties]);
	XCTAssertEqual([[moA allObservedProperties] count], 9, @"Not all properties appear to be obseved.");
	
	XCTAssertEqual([moA numberOfObservers:@"stringProperty1"], 1, @"numberOfObservers doesn't say observed prop is observed.");

	ModelObjectC *moC = [[ModelObjectC alloc] init];
	EBNObservation *obs2 = NewObservationBlock(moC,
	{
		blockSelf.observerCallCount2++;
	});
	
	[obs2 observe:@"*"];
	NSLog(@"moC Observed Propeties: %@", [moC allObservedProperties]);
	moC.protocolIntProperty = 77;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);

	XCTAssertEqual(self.observerCallCount2, 1, @"Observation block got called wrong number of times.");
}

- (void) testObserveAllKeypath
{
	ObservePropertyNoPropCheck(moA, modelObjectBProperty.*,
	{
		blockSelf.observerCallCount1++;
	});
	
	moA.modelObjectBProperty.intProperty = 44;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called wrong number of times.");

	moA.modelObjectBProperty.stringProperty = @"aNewString";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 2, @"Observation block got called wrong number of times.");

	moA.modelObjectBProperty.intProperty = 55;
	moA.modelObjectBProperty.stringProperty = @"aNewerString";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 3, @"Observation block got called wrong number of times.");
}

- (void) testCreateObserverBlock
{
	EBNObservation *blockInfo = NewObservationBlock(moA,
	{
		blockSelf.observerCallCount1++;
		NSLog(@"Inside block.");
	});
	[blockInfo execute];
	
	XCTAssertEqual(self.observerCallCount1, 1, @"Block didn't get called.");
	
	ObserveProperty(moA, intProperty, { });
	
	NSString *debugStr = [moA debugShowAllObservers];
	XCTAssert([debugStr length] > 10, @"debugShowAllObservers isn't recording anything.");
}

- (void) testObservedDealloc
{
	ObserveProperty(moA, intProperty, { });
	
	moA = nil;
	
	XCTAssertTrue(_deallocWasCalled, @"Dealloc protocol not called; either object was held alive, or dealloc didn't call us.");
}

- (void) observedObjectHasBeenDealloced:(id) object endingObservation:(NSString *)keypathStr
{
	if ([keypathStr isEqualToString:@"intProperty"])
	{
		_deallocWasCalled = true;
	}
}

- (void) testObserverDealloc
{
    ModelObjectA *tmpMOA = [[ModelObjectA alloc] init];

	{
		ModelObjectC *mo3 = [[ModelObjectC alloc] init];
        [mo3 setModelObjectAProperty:tmpMOA];

		[moA tell:mo3 when:@"intProperty" changes:^(ModelObjectC *blockObserver, ModelObjectA *blockObserved)
				{
					self.observerCallCount1++;
				}];
	}
	
	moA.intProperty = 55;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 0, @"Observer shouldn't have been called; should have deallocated.");
	XCTAssertTrue(tmpMOA.objectCWasDealloced, @"Observer didn't dealloc when it went out of scope.");
}

- (void) testReadonlyProperty
{
	ObserveProperty(moA, modelObjectBProperty.readonlyProperty.stringProperty1,
	{
		blockSelf.observerCallCount1++;
	});

	moA.modelObjectBProperty.readonlyProperty.stringProperty1 = @"string";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called wrong number of times.");
	
	moA.modelObjectBProperty = nil;
	moA.modelObjectBProperty = [[ModelObjectB alloc] init];
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 2, @"Observation block got called wrong number of times.");

	moA.modelObjectBProperty.readonlyProperty.stringProperty1 = @"string2";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 3, @"Observation block got called wrong number of times.");
}

- (void) testKeypathLoop
{
	ObserveProperty(moA, modelObjectBProperty.modelObjectCProperty.modelObjectAProperty.stringProperty1,
	{
		blockSelf.observerCallCount1++;
	});
	
	moA.modelObjectBProperty.modelObjectCProperty.ModelObjectAProperty = moA;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called wrong number of times.");
	[moA stopTellingAboutChanges:self];
	
	_Pragma("clang diagnostic push")
	_Pragma("clang diagnostic ignored \"-Wshadow\"")
	XCTAssertThrows(ObserveProperty(moA, modelObjectBProperty.modelObjectCProperty.modelObjectAProperty.modelObjectBProperty,
	{
		blockSelf.observerCallCount1++;
	}), @"Should have thrown.");
	_Pragma("clang diagnostic pop")
	
	NSLog(@"%@", [moA debugShowAllObservers]);
}

- (void) testChainedObservations
{
	ObserveProperty(moA, intProperty,
	{
		blockSelf.observerCallCount1++;
		moA.boolProperty = !moA.boolProperty;
	});
	
	ObserveProperty(moA, boolProperty,
	{
		blockSelf.observerCallCount1++;
		moA.intProperty = moA.intProperty++;
	});
	
	moA.intProperty = 5;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 2, @"Recursion guards not working.");
}

// This is where we have obj1.obj2.obj3 and obj2.obj3 as paths, where both pass through obj2.
- (void) testCrossedKeypaths
{
	ObserveProperty(moA, modelObjectBProperty.modelObjectCProperty.stringProperty4,
	{
		blockSelf.observerCallCount1++;
	});
	
	ModelObjectB *moB = moA.modelObjectBProperty;
	ObserveProperty(moB, modelObjectCProperty.stringProperty4,
	{
		blockSelf.observerCallCount2++;
	});

	moA.modelObjectBProperty.modelObjectCProperty.stringProperty4 = @"a string";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Wrong number of calls to observer block.");
	XCTAssertEqual(self.observerCallCount2, 1, @"Wrong number of calls to observer block.");
	
	[moB stopTellingAboutChanges:self];
	moA.modelObjectBProperty.modelObjectCProperty.stringProperty4 = @"another string";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 2, @"Wrong number of calls to observer block.");
	XCTAssertEqual(self.observerCallCount2, 1, @"Wrong number of calls to observer block.");
	
	ObserveProperty(moB, modelObjectCProperty.stringProperty4,
	{
		blockSelf.observerCallCount2++;
	});

	moA.modelObjectBProperty.modelObjectCProperty.stringProperty4 = @"a third string";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 3, @"Wrong number of calls to observer block.");
	XCTAssertEqual(self.observerCallCount2, 2, @"Wrong number of calls to observer block.");
	
	[moB stopTelling:self aboutChangesTo:@"modelObjectCProperty.stringProperty4"];
	moA.modelObjectBProperty.modelObjectCProperty.stringProperty4 = @"string four";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 4, @"Wrong number of calls to observer block.");
	XCTAssertEqual(self.observerCallCount2, 2, @"Wrong number of calls to observer block.");
}

- (void) testAppleKVOCompatibility
{
	__block int observerCallCount = 0;

	ObserveProperty(moA, intProperty,
	{
		observerCallCount++;
	});
	
	[moA addObserver:self forKeyPath:@"intProperty" options:0 context:NULL];
	
	moA.intProperty = 77;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(observerCallCount, 1, @"Wrong number of calls to observer block.");
	XCTAssertTrue(_appleKVOWasCalled, @"Apple KVO method wasn't called.");

}
- (void) testImmedBlock
{
	__block int observerCallCount = 0;
	
	moA.intProperty = 7;

	EBNObservation *blockInfo = [[EBNObservation alloc] initForObserved:moA observer:self
			immedBlock:^(ObservableTests *blockSelf, ModelObjectA *observed, id previousValue)
			{
				int prev = [previousValue intValue];
				XCTAssert(prev == 7, @"Block got told wrong value for previousValue.");
				observerCallCount++;
			}];
			
	[blockInfo observe:@"intProperty"];
	
	moA.intProperty = 33;
	
	XCTAssert(observerCallCount == 1, @"Wrong number of calls to observer block.");
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssert(observerCallCount == 1, @"Wrong number of calls to observer block.");
}

// Apple KVO observer. Verifies compatibility betweeen EBNObservable and KVO.
// Related unit test: testAppleKVOCompatibility.
- (void) observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change
			context:(void *)context
{
    if ([keyPath isEqual:@"intProperty"])
	{
        self->_appleKVOWasCalled = true;
    }
}

#if 0
- (void) testWeakReference
{
    XCTAssertTrue(false, @"Requires test implementation.");
}

- (void) testDeallocOfSub
{
    // Need to check that a keypath of ObjA.ObjB.ObjC where ObjC is referenced
    // outside of ObjB correctly deallocs ObjB and notifies keypath observer
    // of dealloc.
    XCTAssertTrue(false, @"Requires test implementation.");
}

- (void) testCollections
{
    XCTAssertTrue(false, @"Requires test implementation.");
}
#endif

@end



