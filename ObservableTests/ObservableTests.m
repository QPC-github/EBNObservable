/****************************************************************************************************
	ObservableTests.m
	Observable
	
    Created by Chall Fry on 4/19/14.
    Copyright (c) 2013-2014 eBay Software Foundation.

    Unit tests.
*/

@import XCTest;

#import "EBNObservable.h"

// This punches the hole that allows us to force the observer notifications
// instead of being dependent on the run loop. Asyncronous issues
// have to be handled without this.
void EBN_RunLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info);


// -----------------------------------------------------------------------------
//                              Test Objects
// -----------------------------------------------------------------------------
@class ModelObjectA;
@class ModelObjectB;
@class ModelObjectC;
@class ModelObjectD;

//
// Observable Test Object A.
//
@interface ModelObjectA : NSObject

@property (assign) bool					boolProperty;
@property (getter = isCustomBoolProperty) bool customBoolProperty;
@property (assign) int					intProperty;
@property (assign) char					charProperty;
@property (assign) double				doubleProperty;

@property NSString						*stringProperty1;

@property NSMutableData					*dataProperty1;

@property (nonatomic) ModelObjectB		*modelObjectBProperty;
@property (nonatomic) ModelObjectC		*modelObjectCProperty;

@property (nonatomic) bool 				objectCWasDealloced;

// Allow objectCWasDealloced to be changed outside setter.
- (void) changeObjectCWasDeallocedValue:(bool)dealloced;

@end

//
// Observable Test Object B
//
@interface ModelObjectB : NSObject  <NSCopying>

@property (assign) int					intProperty;

@property NSString						*stringProperty;

@property (readonly) ModelObjectA		*readonlyProperty;
@property (strong) ModelObjectC			*modelObjectCProperty;

@end

//
// Protocol used by Test Object C
//
@protocol ModelObjectCProtocol <NSObject>

@property int							protocolIntProperty;

@end

//
// Observable Test Object C
//
@interface ModelObjectC : ModelObjectB <ModelObjectCProtocol>

@property NSString						*stringProperty4;
@property ModelObjectA					*modelObjectAProperty;

@end

//
// Observable Test Object C Category
//
@interface ModelObjectC (CategoryNameGoesHere)

@property float							categoryFloatProperty;

@end

// ------------------------ Test Object Implementations ------------------------

@implementation ModelObjectA

- (void) changeObjectCWasDeallocedValue:(bool)dealloced
{
    _objectCWasDealloced = dealloced;
}

@end

@implementation ModelObjectB

- (instancetype) init
{
	if (self = [super init])
	{
		// Have to set up the readonly property up front.
		_readonlyProperty = [[ModelObjectA alloc] init];
	}
	return self;
}

- (instancetype) copyWithZone:(NSZone *)zone
{
	ModelObjectB *newObj = [[[self class] allocWithZone:zone] init];
	if (newObj)
	{
		newObj->_intProperty = _intProperty;
		newObj->_stringProperty = _stringProperty;
		newObj->_readonlyProperty = _readonlyProperty;
		newObj->_modelObjectCProperty = _modelObjectCProperty;
	}
	
	return newObj;
}

@end


@implementation ModelObjectC

@synthesize protocolIntProperty;

- (void) dealloc
{
	if (self.modelObjectAProperty)
        [self.modelObjectAProperty changeObjectCWasDeallocedValue:true];
}

@end

@implementation ModelObjectC (CategoryNameGoesHere)

- (float) categoryFloatProperty
{
	// You can declare a property in a category, but you can't back it with an ivar, which means
	// you can't @synthesize it--as the autogenerated getter and setter need to use the ivar that isn't there.
	return 42.0;
}

- (void) setCategoryFloatProperty:(float)categoryFloatProperty
{
	// Oh yeah, we set that value alright.
}

@end


// -----------------------------------------------------------------------------
// Observable Tests
// -----------------------------------------------------------------------------
@interface ObservableTests : XCTestCase
{
	// These are deliberately not properties.
	ModelObjectA *moA;
}

@property (nonatomic) int observerCallCount1;			// Counts the number of times a test's observer block is called.
@property (nonatomic) int observerCallCount2;			// Counts the number of times a test's observer block is called.
@property (nonatomic) int propValInBlock;				// Receives the new integer value of the observed property.

@property (nonatomic) bool deallocWasCalled;			// Used by testObservedDealloc to confirm that dealloc message for observed property is triggered.
@property (nonatomic) bool appleKVOWasCalled;			// Used by testAppleKVOCompatibility to confirm that EBNObservable is compatible with Apple's KVO.


@end


@implementation ObservableTests

- (void) setUp
{
    [super setUp];
    
    self.observerCallCount1 = 0;
    self.observerCallCount2 = 0;
    self.propValInBlock = 0;
    
    _deallocWasCalled = false;
    //	_ModelObjectCWasDealloced = false;
	_appleKVOWasCalled = false;
	
	moA = [[ModelObjectA alloc] init];
	moA.intProperty = 99;
	moA.stringProperty1 = @"old value";
	moA.modelObjectBProperty = [[ModelObjectB alloc] init];
	moA.modelObjectCProperty = [[ModelObjectC alloc] init];
	moA.modelObjectBProperty.modelObjectCProperty = [[ModelObjectC alloc] init];
}

- (void) tearDown
{
    [super tearDown];
}

- (void) testBasicObservation
{
	ObserveProperty(moA, intProperty,
	{
		blockSelf.observerCallCount1++;
		_propValInBlock = observed.intProperty;
	});
	
	moA.intProperty = 5;
	
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called.");
	XCTAssertEqual(self.propValInBlock, 5, @"Property doesn't have the value it should.");
}

- (void) testBasicObservationKeypath
{
	[moA tell:self when:@"modelObjectBProperty.intProperty" changes:
			^(ObservableTests *blockSelf, ModelObjectA *observed)
			{
				blockSelf.observerCallCount1++;
				blockSelf.propValInBlock = observed.modelObjectBProperty.intProperty;
			}];
	
	moA.modelObjectBProperty.intProperty = 8;
	moA.modelObjectBProperty = nil;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);

	moA.modelObjectBProperty = [[ModelObjectB alloc] init];
	moA.modelObjectBProperty.intProperty = 5;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	
	XCTAssertEqual(self.observerCallCount1, 2, @"Observation block got called wrong number of times.");
	XCTAssertEqual(self.propValInBlock, 5, @"Property doesn't have the value it should.");
}

- (void) testBasicObservationRemoval
{
	ObserveProperty(moA, intProperty,
	{
		blockSelf.observerCallCount1++;
		blockSelf.propValInBlock = observed.intProperty;
	});
	
	moA.intProperty = 4;
	moA.intProperty = 5;
	[moA stopTellingAboutChanges:self];
	moA.intProperty = 6;
	
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	
	moA.intProperty = 10;
	
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got too many times.");
	XCTAssertEqual(self.propValInBlock, 6, @"Observation block got called with wrong value.");
}

- (void) testBasicObservationKeypathRemoval
{
	ObserveProperty(moA, modelObjectBProperty.intProperty,
	{
		blockSelf.observerCallCount1++;
		blockSelf.propValInBlock = observed.modelObjectBProperty.intProperty;
	});
	
	moA.intProperty = 4;
	moA.modelObjectBProperty.intProperty = 5;
	[moA stopTellingAboutChanges:self];
	moA.modelObjectBProperty.intProperty = 6;
	
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	
	moA.modelObjectBProperty.intProperty = 10;

	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called too many times.");
	XCTAssertEqual(self.propValInBlock, 6, @"Observation block got called with wrong value.");
}

- (void) testArrayObservation
{
	__block NSString *stringValInBlock = nil;
	
	[moA tell:self whenAny:@[@"stringProperty1", @"intProperty", @"modelObjectBProperty"]
			changes:^(ObservableTests *blockSelf, ModelObjectA *observed)
			{
				blockSelf.observerCallCount1++;
				blockSelf.propValInBlock = observed.intProperty;
				stringValInBlock = [observed.stringProperty1 copy];
			}];
				
	moA.intProperty = 4;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called too many times.");
	XCTAssertEqual(self.propValInBlock, 4, @"Observation block got called with wrong value.");

	self.observerCallCount1 = 0;
	moA.stringProperty1 = @"new value";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called too many times.");
	XCTAssertEqualObjects(stringValInBlock, @"new value", @"Observation block got called with wrong value.");

	self.observerCallCount1 = 0;
	moA.modelObjectBProperty.intProperty = 6;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 0, @"Observation block got called too many times.");
	
	self.observerCallCount1 = 0;
	moA.modelObjectBProperty = [[ModelObjectB alloc] init];
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called too many times.");

	self.observerCallCount1 = 0;
	moA.stringProperty1 = @"newer value";
	moA.intProperty = 10;
	moA.modelObjectBProperty = [[ModelObjectB alloc] init];
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called too many times.");
	XCTAssertEqual(self.propValInBlock, 10, @"Observation block got called with wrong value.");
	XCTAssertEqualObjects(stringValInBlock, @"newer value", @"Observation block got called with wrong value.");

	self.observerCallCount1 = 0;
	[moA stopTellingAboutChanges:self];
	moA.stringProperty1 = @"newest value";
	moA.intProperty = 11;
	moA.modelObjectBProperty = [[ModelObjectB alloc] init];
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 0, @"Observation block got called too many times.");
}

- (void) testArrayObservationKeypath
{
	__block int intVal2InBlock = 0;
	__block NSString *stringValInBlock = nil;
	
	[moA tell:self whenAny:@[@"modelObjectBProperty.intProperty", @"intProperty",
			@"modelObjectBProperty.modelObjectCProperty.stringProperty4"]
			changes:^(ObservableTests *blockSelf, ModelObjectA *observed)
			{
				blockSelf.observerCallCount1++;
				blockSelf.propValInBlock = observed.intProperty;
				intVal2InBlock = observed.modelObjectBProperty.intProperty;
				stringValInBlock = [observed.modelObjectBProperty.modelObjectCProperty.stringProperty4 copy];
			}];

	NSLog(@"%@", [moA debugShowAllObservers]);

	moA.modelObjectBProperty.intProperty = 40;
	moA.intProperty = 33;
	moA.modelObjectBProperty.modelObjectCProperty.stringProperty4 = @"some value";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called too many times.");
	XCTAssertEqual(self.propValInBlock, 33, @"Observation block got called with wrong value.");
	
	self.observerCallCount1 = 0;
	moA.modelObjectBProperty = nil;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called too many times.");
	XCTAssertEqual(intVal2InBlock, 0, @"Observation block got called with wrong value.");

	self.observerCallCount1 = 0;
	moA.modelObjectBProperty = [[ModelObjectB alloc] init];
	moA.modelObjectBProperty.modelObjectCProperty = [[ModelObjectC alloc] init];
	moA.modelObjectBProperty.modelObjectCProperty.stringProperty4 = @"changed value";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block didn't get called.");
	XCTAssertEqualObjects(stringValInBlock, @"changed value", @"Observation block got called with wrong value.");

}

- (void) testObserveAll
{
	EBNObservation *blockInfo = NewObservationBlock(moA,
	{
		blockSelf.observerCallCount1++;
	});
	
	[blockInfo observe:@"*"];
	
	moA.intProperty = 33;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	moA.doubleProperty = 33.0;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	moA.charProperty = 'x';
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	[moA setStringProperty1:@"what?"];
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 4, @"Observation block got called wrong number of times.");
	
	moA.modelObjectBProperty.stringProperty	= @"who?";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 4, @"Observation block got called wrong number of times.");
	
	NSLog(@"moA Observed Properties: %@", [moA allObservedProperties]);
	XCTAssertEqual([[moA allObservedProperties] count], 10, @"Not all properties appear to be obseved.");
	
	XCTAssertEqual([moA numberOfObservers:@"stringProperty1"], 1, @"numberOfObservers doesn't say observed prop is observed.");

	ModelObjectC *moC = [[ModelObjectC alloc] init];
	EBNObservation *obs2 = NewObservationBlock(moC,
	{
		blockSelf.observerCallCount2++;
	});
	
	[obs2 observe:@"*"];
	NSLog(@"moC Observed Propeties: %@", [moC allObservedProperties]);
	moC.protocolIntProperty = 77;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);

	XCTAssertEqual(self.observerCallCount2, 1, @"Observation block got called wrong number of times.");
}

- (void) testObserveAllKeypath
{
	ObservePropertyNoPropCheck(moA, modelObjectBProperty.*,
	{
		blockSelf.observerCallCount1++;
	});
	
	moA.modelObjectBProperty.intProperty = 44;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called wrong number of times.");

	moA.modelObjectBProperty.stringProperty = @"aNewString";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 2, @"Observation block got called wrong number of times.");

	moA.modelObjectBProperty.intProperty = 55;
	moA.modelObjectBProperty.stringProperty = @"aNewerString";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 3, @"Observation block got called wrong number of times.");
}

- (void) testCreateObserverBlock
{
	EBNObservation *blockInfo = NewObservationBlock(moA,
	{
		blockSelf.observerCallCount1++;
		NSLog(@"Inside block.");
	});
	[blockInfo execute];
	
	XCTAssertEqual(self.observerCallCount1, 1, @"Block didn't get called.");
	
	ObserveProperty(moA, intProperty, { });
	
	NSString *debugStr = [moA debugShowAllObservers];
	XCTAssert([debugStr length] > 10, @"debugShowAllObservers isn't recording anything.");
}

- (void) testObservedDealloc
{
	ObserveProperty(moA, intProperty, { });
	
	moA = nil;
	
	XCTAssertTrue(_deallocWasCalled, @"Dealloc protocol not called; either object was held alive, or dealloc didn't call us.");
}

- (void) observedObjectHasBeenDealloced:(id) object endingObservation:(NSString *)keypathStr
{
	if ([keypathStr isEqualToString:@"intProperty"])
	{
		_deallocWasCalled = true;
	}
}

- (void) testObserverDealloc
{
    ModelObjectA *tmpMOA = [[ModelObjectA alloc] init];

	{
		ModelObjectC *mo3 = [[ModelObjectC alloc] init];
        [mo3 setModelObjectAProperty:tmpMOA];

		[moA tell:mo3 when:@"intProperty" changes:^(ModelObjectC *blockObserver, ModelObjectA *blockObserved)
				{
					self.observerCallCount1++;
				}];
	}
	
	moA.intProperty = 55;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 0, @"Observer shouldn't have been called; should have deallocated.");
	XCTAssertTrue(tmpMOA.objectCWasDealloced, @"Observer didn't dealloc when it went out of scope.");
}

- (void) testReadonlyProperty
{
	ObserveProperty(moA, modelObjectBProperty.readonlyProperty.stringProperty1,
	{
		blockSelf.observerCallCount1++;
	});

	moA.modelObjectBProperty.readonlyProperty.stringProperty1 = @"string";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called wrong number of times.");
	
	moA.modelObjectBProperty = nil;
	moA.modelObjectBProperty = [[ModelObjectB alloc] init];
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 2, @"Observation block got called wrong number of times.");

	moA.modelObjectBProperty.readonlyProperty.stringProperty1 = @"string2";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 3, @"Observation block got called wrong number of times.");
}

- (void) testKeypathLoop
{
	ObserveProperty(moA, modelObjectBProperty.modelObjectCProperty.modelObjectAProperty.stringProperty1,
	{
		blockSelf.observerCallCount1++;
	});
	
	moA.modelObjectBProperty.modelObjectCProperty.modelObjectAProperty = moA;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Observation block got called wrong number of times.");
	[moA stopTellingAboutChanges:self];
	
	_Pragma("clang diagnostic push")
	_Pragma("clang diagnostic ignored \"-Wshadow\"")
	XCTAssertThrows(ObserveProperty(moA, modelObjectBProperty.modelObjectCProperty.modelObjectAProperty.modelObjectBProperty,
	{
		blockSelf.observerCallCount1++;
	}), @"Should have thrown.");
	_Pragma("clang diagnostic pop")
	
	NSLog(@"%@", [moA debugShowAllObservers]);
}

- (void) testChainedObservations
{
	ObserveProperty(moA, intProperty,
	{
		blockSelf.observerCallCount1++;
		moA.boolProperty = !moA.boolProperty;
	});
	
	ObserveProperty(moA, boolProperty,
	{
		blockSelf.observerCallCount1++;
		moA.intProperty = moA.intProperty++;
	});
	
	moA.intProperty = 5;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 2, @"Recursion guards not working.");
}

// This is where we have obj1.obj2.obj3 and obj2.obj3 as paths, where both pass through obj2.
- (void) testCrossedKeypaths
{
	ObserveProperty(moA, modelObjectBProperty.modelObjectCProperty.stringProperty4,
	{
		blockSelf.observerCallCount1++;
	});
	
	ModelObjectB *moB = moA.modelObjectBProperty;
	ObserveProperty(moB, modelObjectCProperty.stringProperty4,
	{
		blockSelf.observerCallCount2++;
	});

	moA.modelObjectBProperty.modelObjectCProperty.stringProperty4 = @"a string";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 1, @"Wrong number of calls to observer block.");
	XCTAssertEqual(self.observerCallCount2, 1, @"Wrong number of calls to observer block.");
	
	[moB stopTellingAboutChanges:self];
	moA.modelObjectBProperty.modelObjectCProperty.stringProperty4 = @"another string";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 2, @"Wrong number of calls to observer block.");
	XCTAssertEqual(self.observerCallCount2, 1, @"Wrong number of calls to observer block.");
	
	ObserveProperty(moB, modelObjectCProperty.stringProperty4,
	{
		blockSelf.observerCallCount2++;
	});

	moA.modelObjectBProperty.modelObjectCProperty.stringProperty4 = @"a third string";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 3, @"Wrong number of calls to observer block.");
	XCTAssertEqual(self.observerCallCount2, 2, @"Wrong number of calls to observer block.");
	
	[moB stopTelling:self aboutChangesTo:@"modelObjectCProperty.stringProperty4"];
	moA.modelObjectBProperty.modelObjectCProperty.stringProperty4 = @"string four";
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(self.observerCallCount1, 4, @"Wrong number of calls to observer block.");
	XCTAssertEqual(self.observerCallCount2, 2, @"Wrong number of calls to observer block.");
}

- (void) testAppleKVOCompatibility
{
	__block int observerCallCount = 0;
	
	
	// First use Apple's KVO, then Observable to observe on the object
	ModelObjectA *appleKVOFirst = [[ModelObjectA alloc] init];
	[appleKVOFirst addObserver:self forKeyPath:@"intProperty" options:0 context:NULL];
	ObserveProperty(appleKVOFirst, intProperty,
	{
		observerCallCount++;
	});
	
	appleKVOFirst.intProperty = 77;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(observerCallCount, 1, @"Wrong number of calls to observer block.");
	XCTAssertTrue(_appleKVOWasCalled, @"Apple KVO method wasn't called.");
	
	observerCallCount = 0;

	// This time we do Observable first, then Apple's KVO
	ModelObjectA *observableFirst = [[ModelObjectA alloc] init];
	ObserveProperty(observableFirst, intProperty,
	{
		observerCallCount++;
	});
	XCTAssertEqual([observableFirst class], [ModelObjectA class], @"Class method returns wrong thing.");
	XCTAssertEqual([observableFirst superclass], [NSObject class], @"Class method returns wrong thing.");
	[observableFirst addObserver:self forKeyPath:@"intProperty" options:0 context:NULL];
	
	observableFirst.intProperty = 77;
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssertEqual(observerCallCount, 1, @"Wrong number of calls to observer block.");
	XCTAssertTrue(_appleKVOWasCalled, @"Apple KVO method wasn't called.");
	
	// Because Apple's KVO is pissy
	[appleKVOFirst removeObserver:self forKeyPath:@"intProperty"];
	[observableFirst removeObserver:self forKeyPath:@"intProperty"];
	
	// Test that further KVO registrations don't cause a subclassing cascade
	[appleKVOFirst addObserver:self forKeyPath:@"boolProperty" options:0 context:NULL];
	XCTAssertEqual([appleKVOFirst class], [ModelObjectA class], @"Class method returns wrong thing.");
	XCTAssert(strcmp(object_getClassName(appleKVOFirst), "NSKVONotifying_ModelObjectA") == 0,
			@"The actual class for this object should the Apple KVO subclass.");
	XCTAssertEqual(class_getSuperclass(object_getClass(appleKVOFirst)), [ModelObjectA class],
			@"The base class should be the direct superclass of the Apple KVO subclass at this point.");

	// Same idea with the Observable-first path
	[observableFirst addObserver:self forKeyPath:@"boolProperty" options:0 context:NULL];
	ObserveProperty(observableFirst, boolProperty,
	{
		observerCallCount++;
	});
	
		// Note that this is not the correct answer, but Apple's KVO has a bug where they return the previous
		// subclass' type, not the previous value of [self class].
	XCTAssert(strcmp(class_getName([observableFirst class]), "NSKVONotifying_ModelObjectA"),
			@"Class method returns wrong thing.");
	
		//
	XCTAssertEqual([[observableFirst class] ebn_properBaseClass], [ModelObjectA class],
			@"getProperBaseClass isn't returning the base class.");
	
	XCTAssert(strcmp(object_getClassName(observableFirst), "NSKVONotifying_ModelObjectA_EBNShadowClass") == 0,
			@"The actual class for this object should be Observable's subclass of KVO's subclass of the original object.");
	XCTAssert(strcmp(class_getName(class_getSuperclass(object_getClass(observableFirst))), "ModelObjectA_EBNShadowClass") == 0,
			@"Superclass of shadowclass should be Observable-created subclass.");
	XCTAssertEqual(class_getSuperclass(class_getSuperclass(object_getClass(observableFirst))), [ModelObjectA class],
			@"Superclass of superclass of shadowclass should be base class in this case.");

	// Because Apple's KVO is pissy
	[appleKVOFirst removeObserver:self forKeyPath:@"boolProperty"];
	[observableFirst removeObserver:self forKeyPath:@"boolProperty"];
	
}

- (void) testImmedBlock
{
	__block int observerCallCount = 0;
	
	moA.intProperty = 7;

	EBNObservation *blockInfo = [[EBNObservation alloc] initForObserved:moA observer:self
			immedBlock:^(ObservableTests *blockSelf, ModelObjectA *observed, id previousValue)
			{
				int prev = [previousValue intValue];
				XCTAssert(prev == 7, @"Block got told wrong value for previousValue.");
				observerCallCount++;
			}];
			
	[blockInfo observe:@"intProperty"];
	
	moA.intProperty = 33;
	
	XCTAssert(observerCallCount == 1, @"Wrong number of calls to observer block.");
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssert(observerCallCount == 1, @"Wrong number of calls to observer block.");
}

// Apple KVO observer. Verifies compatibility betweeen EBNObservable and KVO.
// Related unit test: testAppleKVOCompatibility.
- (void) observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change
			context:(void *)context
{
    if ([keyPath isEqual:@"intProperty"])
	{
        self->_appleKVOWasCalled = true;
    }
}

- (void) testNSCFObjects
{
	// Create a CF object, bridge it to a NS pointer, and observe it.
	ModelObjectA *moa = [[ModelObjectA alloc] init];
	CFStringRef cfStr = CFSTR("this is literally a string literal");
	moa.stringProperty1 = CFBridgingRelease(cfStr);
	
	[moa tell:self when:@"stringProperty1" changes:^(ObservableTests *blockSelf, NSString *observed)
	{
		blockSelf.observerCallCount1++;
	}];
	
	cfStr = CFSTR("this is another literal");
	moa.stringProperty1 = CFBridgingRelease(cfStr);
	
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssert(_observerCallCount1 == 1, @"Wrong number of calls to observer block.");
	
	// Same idea as above, but now we're making a CF object whose NS counterpart has settable properties,
	// and observing the properties of the CF object via a keypath
	CFMutableDataRef dataRef = CFDataCreateMutable(nil, 100);
	moa.dataProperty1 = CFBridgingRelease(dataRef);
	
	[moa tell:self when:@"dataProperty1.length" changes:^(ObservableTests *blockSelf, NSMutableData *observed)
	{
		blockSelf.observerCallCount1++;
	}];
	
	[moa.dataProperty1 increaseLengthBy:50];
	
	// In this case, the observer won't fire because we can't observe the CFMutableDataRef
	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssert(_observerCallCount1 == 1, @"Wrong number of calls to observer block.");
}

- (void) testClassHiding
{
	ModelObjectA *moa = [[ModelObjectA alloc] init];
	
	Class origClass = [moa class];
	XCTAssert(origClass == [ModelObjectA class], @"Original class doesn't match up.");
	
	[moa tell:self when:@"stringProperty1" changes:^(ObservableTests *blockSelf, NSString *observed)
	{
		blockSelf.observerCallCount1++;
	}];
	
	Class shadowClass = object_getClass(moa);
	Class baseClass = [moa class];
	XCTAssert(strcmp(class_getName(shadowClass), "ModelObjectA_EBNShadowClass") == 0, @"Shadow Class has wrong name.");
	XCTAssert(baseClass == [ModelObjectA class], @"Base class doesn't match up.");
}

- (void) testCopyBehavior
{
	ModelObjectB *mob1 = [[ModelObjectB alloc] init];
	
	[mob1 tell:self when:@"stringProperty" changes:^(ObservableTests *blockSelf, NSString *observed)
	{
		blockSelf.observerCallCount1++;
	}];

	ModelObjectB *mob2 = [mob1 copyWithZone:NULL];
	
	mob2.stringProperty = @"should not trigger observation.";

	EBN_RunLoopObserverCallBack(nil, kCFRunLoopAfterWaiting, nil);
	XCTAssert(_observerCallCount1 == 0, @"Wrong number of calls to observer block.");
}


@end



